# Архитектура Receipt Parser Yomi Bot

## Обзор системы

Receipt Parser Yomi Bot - это Telegram-бот для автоматической обработки чеков самозанятых с последующей загрузкой на Google Drive и добавлением данных в Google Sheets. Поддерживает многопользовательский режим работы с автоматическим созданием персональных папок и таблиц для каждого пользователя.

## Компоненты системы

### 1. Telegram Bot Layer (`bot.py`)

**Назначение:** Основной интерфейс взаимодействия с пользователем через Telegram.

**Основные функции:**
- Обработка команд (`/start`, `/help`, `/full_analyze`)
- Прием фото чеков (одиночных и пачкой)
- Прием PDF документов
- Обработка текстовых сообщений (ссылок на чеки ФНС)
- Автоматическая обработка и загрузка без подтверждения
- Массовая обработка чеков из папки Drive

**Хранилище данных:**
- `user_structures` - структуры папок/таблиц пользователей (chat_id -> user_structure)
- `analysis_folders` - информация о папках для массовой обработки (user_id -> folder_info)

**Основные обработчики:**
- `start()` - инициализация пользователя, создание структуры
- `help_command()` - отображение справки
- `full_analyze()` - запуск массовой обработки
- `handle_photo()` - обработка фотографий с автоматической загрузкой
- `handle_document()` - обработка PDF файлов
- `handle_text()` - обработка текстовых сообщений
- `button_callback()` - обработка кнопок (запуск анализа)
- `process_analysis_folder()` - массовая обработка папки

### 2. Receipt Processing Layer

#### 2.1 Receipt Processor (`receipt_processor.py`)

**Назначение:** Координация процесса обработки чека.

**Основные методы:**
- `process_receipt_image(image_path)` - полная обработка изображения чека
- `upload_and_save(image_path, receipt_data)` - загрузка на Drive и сохранение в Sheets

**Рабочий процесс:**
1. Извлечение QR-кода (если есть)
2. Парсинг данных через OpenAI Vision
3. Валидация данных (мягкая - всегда возвращает True с деталями ошибок)
4. Координация загрузки

**Изменения:**
- Валидация не блокирует обработку, а добавляет поле `error_details` в данные
- Поддержка source_link и source_name для отслеживания источника чека

#### 2.2 OpenAI Vision Parser (`openai_vision.py`)

**Назначение:** Извлечение данных из изображения чека с помощью GPT-4o-mini Vision API.

**Основные методы:**
- `parse_receipt(image_path)` - отправка изображения в OpenAI и получение структурированных данных
- `encode_image(image_path)` - кодирование изображения в base64

**Извлекаемые данные:**
- ФИО (Фамилия И.О.)
- Сумма (с символом ₽)
- Наименование услуг
- ИНН продавца (12 цифр)
- ИНН покупателя (10 или 12 цифр)
- Дата (dd.mm.yyyy)
- Статус (Действителен/Аннулирован)

#### 2.3 QR Parser (`qr_parser.py`)

**Назначение:** Извлечение и парсинг QR-кодов с чеков ФНС.

**Основные функции:**
- `extract_qr_from_image(image_path)` - извлечение URL из QR-кода
- `parse_fns_url(url)` - парсинг URL ФНС для получения ИНН и ID чека

**Технологии:**
- `pyzbar` - основной метод декодирования
- `opencv` - улучшение качества изображения для декодирования

#### 2.4 OCR Handler (`ocr_handler.py`)

**Назначение:** Резервный метод извлечения данных через OCR (в настоящее время не используется в основном потоке).

**Основные функции:**
- `extract_text_from_image(image_path)` - OCR через Tesseract
- `parse_receipt_data(ocr_text)` - извлечение структурированных данных из текста
- `validate_and_clean_data(data)` - валидация извлеченных данных

### 3. Google Integration Layer

#### 3.1 Google Authentication (`google_auth.py`)

**Назначение:** Управление авторизацией в Google API.

**Основные функции:**
- `get_google_credentials()` - получение и обновление credentials
- Автоматическая авторизация при первом запуске
- Сохранение токенов в `token.pickle`

**Области доступа (SCOPES):**
- `drive.file` - создание и управление файлами на Drive
- `spreadsheets` - чтение и запись в Google Sheets

#### 3.2 User Manager (`user_manager.py`)

**Назначение:** Управление структурой папок и таблиц для каждого пользователя.

**Основные методы:**
- `get_chat_name()` - формирование имени для папки/таблицы
- `get_or_create_user_structure()` - создание или получение структуры пользователя
- `_find_user_folder()` - поиск существующей папки
- `_create_user_folder()` - создание новой папки
- `_create_user_sheet()` - создание таблицы с заголовками

**Структура для пользователя:**
```
Корневая папка
└── @username или "Название чата"
    ├── Реестр чеков (Google Sheets)
    └── (подпапки по ИНН создаются DriveHandler)
```

#### 3.3 Drive Handler (`drive_handler.py`)

**Назначение:** Управление файлами на Google Drive.

**Структура папок:**
```
Корневая папка (GOOGLE_DRIVE_FOLDER_ID)
├── @username1 (папка пользователя)
│   ├── ИНН покупателя (например: 9705246070)
│   │   └── Месяц-год (например: 08-2025)
│   │       └── Файлы чеков (Фамилия И.О. дата.jpg)
│   └── @username1 2026-01-16 10-30 (папка анализа)
│       └── Файлы для массовой обработки
└── @username2 (папка пользователя)
    └── ...
```

**Основные методы:**
- `upload_file()` - загрузка файла с автоматическим созданием структуры папок
- `get_or_create_folder()` - создание или получение папки
- `create_analysis_folder()` - создание папки для массовой обработки
- `list_files_in_folder()` - получение списка файлов
- `download_file()` - скачивание файла

**Формат имени файла:** `{ФИО} {дата}.{расширение}`  
Пример: `Сабатаров А.Г. 13.08.2025.jpg`

#### 3.4 Sheets Handler (`sheets_handler.py`)

**Назначение:** Управление данными в Google Sheets.

**Структура таблицы (10 колонок):**
| Дата | ФИО | ИНН покупателя | Наименование услуг | Сумма | Статус | Ссылка ФНС | Ссылка Drive | Добавлено (МСК) | Источник |
|------|-----|----------------|-------------------|-------|--------|-----------|--------------|-----------------|----------|

**Основные методы:**
- `add_receipt_data(data, source_link, source_name)` - добавление строки с данными чека
- `setup_headers()` - установка заголовков таблицы (однократно)

**Новые поля:**
- Колонка I: Timestamp добавления в МСК
- Колонка J: Источник ("Прямая загрузка" или гиперссылка на папку анализа)

#### 3.5 Analysis Sheet Handler (`analysis_handler.py`)

**Назначение:** Создание и управление таблицами для массового анализа.

**Основные методы:**
- `create_analysis_spreadsheet()` - создание новой таблицы в папке анализа
- `add_receipt_to_sheet()` - добавление чека в таблицу анализа

**Структура таблицы анализа (9 колонок):**
- Колонки A-H: как в основной таблице
- Колонка I: Ошибки обработки

**Особенности:**
- Создается отдельная таблица для каждой папки анализа
- Размещается внутри папки анализа на Drive
- Содержит только чеки из данной папки

#### 3.6 Statistics Handler (`statistics_handler.py`)

**Назначение:** Сбор статистики использования бота.

**Основные методы:**
- `log_action()` - логирование действий пользователя
- `update_user_stats()` - обновление статистики пользователя
- `setup_statistics_sheets()` - установка заголовков

**Два листа в таблице статистики:**

1. **"Статистика пользователей"** (8 колонок):
   - User ID
   - Username
   - Первое использование
   - Последнее использование
   - Всего чеков
   - Успешно
   - Ошибок
   - Дней активен

2. **"Лог действий"** (6 колонок):
   - Timestamp (МСК)
   - User ID
   - Username
   - Действие
   - Результат
   - Детали

**Применение:** Опционально, требует STATISTICS_SHEET_ID в .env

## Поток данных

### Первый запуск пользователя

```
1. Пользователь отправляет /start
   ↓
2. bot.py: start() -> get_or_init_user_structure()
   ↓
3. user_manager.get_or_create_user_structure()
   ├── Поиск существующей папки по имени пользователя
   ├── Создание папки (если не найдена)
   ├── Создание таблицы "Реестр чеков" в папке
   └── Установка заголовков таблицы
   ↓
4. Сохранение структуры в памяти (user_structures)
   ↓
5. Отправка приветствия со ссылками на папку и таблицу
   ↓
6. Логирование в статистику (если включена)
```

### Обработка одиночного фото

```
1. Пользователь отправляет фото
   ↓
2. bot.py: handle_photo()
   ├── Получение/создание структуры пользователя
   └── Скачивание во временный файл
   ↓
3. receipt_processor.process_receipt_image()
   ├── qr_parser.extract_qr_from_image() → получение URL ФНС
   ├── openai_vision.parse_receipt() → извлечение данных
   └── ocr_handler.validate_and_clean_data() → мягкая валидация
   ↓
4. receipt_processor.upload_and_save()
   ├── drive_handler.upload_file() → загрузка в папку пользователя
   └── sheets_handler.add_receipt_data() → добавление в таблицу пользователя
   ↓
5. Отправка результата пользователю (с ошибками, если есть)
   ↓
6. Логирование в статистику
```

### Массовая обработка чеков (/full_analyze)

```
1. Пользователь отправляет /full_analyze
   ↓
2. bot.py: full_analyze()
   ├── Получение структуры пользователя
   ├── Создание папки анализа: "@username ГГГГ-ММ-ДД ЧЧ-ММ"
   └── Сохранение информации о папке (analysis_folders)
   ↓
3. Отправка ссылки на папку с кнопкой "Начать анализ"
   ↓
4. Пользователь загружает чеки в папку вручную
   ↓
5. Пользователь нажимает кнопку "Начать анализ"
   ↓
6. bot.py: button_callback() -> process_analysis_folder()
   ├── drive_handler.list_files_in_folder() → получение списка файлов
   ├── analysis_handler.create_analysis_spreadsheet() → создание таблицы анализа
   └── Для каждого файла:
       ├── drive_handler.download_file() → скачивание
       ├── Конвертация PDF в JPG (если PDF)
       ├── receipt_processor.process_receipt_image() → обработка
       ├── analysis_handler.add_receipt_to_sheet() → добавление в таблицу анализа
       ├── sheets_handler.add_receipt_data() → добавление в корневую таблицу пользователя
       └── Сбор статистики (успешные/неуспешные)
   ↓
7. Формирование итогового отчета
   ↓
8. Отправка отчета со ссылками на обе таблицы
   ↓
9. Удаление информации о папке из памяти
   ↓
10. Логирование в статистику
```

### Обработка PDF

```
1. Пользователь отправляет PDF
   ↓
2. bot.py: handle_document()
   ↓
3. Проверка расширения .pdf
   ↓
4. Скачивание во временный файл
   ↓
5. pdf2image.convert_from_path() → конвертация в JPG
   ↓
6. receipt_processor.process_receipt_image()
   ↓
7. Отображение данных с кнопками подтверждения
   ↓
8. Загрузка оригинального PDF (не JPG) на Drive
```

## Технологический стек

### Backend
- **Python 3.12** - основной язык
- **python-telegram-bot 20.7** - Telegram Bot API
- **OpenAI Python SDK** - интеграция с GPT-4o-mini Vision

### Computer Vision & OCR
- **pyzbar** - декодирование QR-кодов
- **opencv-python** - обработка изображений
- **pytesseract** - OCR (резервный метод)
- **pdf2image** - конвертация PDF в изображения
- **Pillow** - работа с изображениями

### Google APIs
- **google-api-python-client** - клиент для Google APIs
- **google-auth-oauthlib** - OAuth 2.0 авторизация
- **google-auth-httplib2** - HTTP транспорт

### Утилиты
- **python-dotenv** - управление переменными окружения
- **requests** - HTTP запросы

## Конфигурация

### Переменные окружения (.env)

```env
TELEGRAM_BOT_TOKEN=your_telegram_bot_token
GOOGLE_DRIVE_FOLDER_ID=your_drive_folder_id  # Корневая папка для всех пользователей
GOOGLE_SHEET_ID=your_spreadsheet_id  # Не используется в мультипользовательском режиме
OPENAI_API_KEY=your_openai_api_key
STATISTICS_SHEET_ID=your_statistics_sheet_id  # Опционально, для статистики
```

### Файлы конфигурации

- `credentials.json` - OAuth 2.0 credentials от Google Cloud
- `token.pickle` - сохраненные Google API токены (генерируется автоматически)
- `.env` - переменные окружения (не в git)

## Безопасность

### Секретные данные
Все секретные данные хранятся в переменных окружения и не коммитятся в репозиторий:
- Telegram Bot Token
- OpenAI API Key
- Google OAuth credentials

### .gitignore
```
.env
credentials.json
token.pickle
token.json
```

### OAuth Flow
При первом запуске приложение открывает браузер для авторизации в Google. После успешной авторизации токены сохраняются локально в `token.pickle`.

## Обработка ошибок

### На уровне Bot
- Отлов всех исключений с логированием
- Информативные сообщения об ошибках пользователю
- Автоматическая очистка временных файлов

### На уровне процессинга
- Валидация обязательных полей
- Проверка форматов данных (ИНН, дата)
- Резервные методы извлечения данных

### На уровне интеграций
- Обновление Google токенов при истечении
- Обработка ошибок API (rate limits, timeouts)
- Retry механизмы для HTTP запросов

## Масштабируемость

### Текущие ограничения
- Временное хранилище в памяти (`user_structures`, `analysis_folders`)
- Синхронная обработка файлов при массовом анализе
- Отсутствие персистентности структур пользователей (при перезапуске пересоздаются)

### Преимущества текущей архитектуры
- Каждый пользователь имеет изолированную структуру данных
- Масштабируется по количеству пользователей
- Нет единой точки отказа в хранилище данных
- Простота управления доступами (через Google Drive permissions)

### Рекомендации для production
1. **Хранилище:** Использовать Redis/PostgreSQL для хранения user_structures
2. **Очереди:** Внедрить Celery/RQ для асинхронной обработки массовых папок
3. **Логирование:** Централизованное логирование (ELK, Sentry)
4. **Мониторинг:** Метрики обработки, алерты на ошибки, дашборд статистики
5. **Кэширование:** Кэширование результатов OpenAI для одинаковых изображений
6. **Backup:** Автоматическое резервное копирование таблиц статистики
7. **Rate limiting:** Ограничение запросов на пользователя для защиты от злоупотреблений

## Стоимость использования

- **OpenAI GPT-4o-mini Vision:** ~$0.0003 за чек (~0.03₽)
- **Google Drive API:** Бесплатно (в пределах квот)
- **Google Sheets API:** Бесплатно (в пределах квот)
- **Telegram Bot API:** Бесплатно

**Квоты Google API:**
- Drive: 1 000 000 запросов/день
- Sheets: 500 запросов/100 секунд на пользователя

## Расширяемость

### Возможные улучшения
1. **Редактирование данных:** UI для ручной корректировки распознанных данных через inline-клавиатуру
2. **Статистика:** Расширенный дашборд с аналитикой по чекам, пользователям, трендам
3. **Экспорт:** Выгрузка данных в различных форматах (Excel, CSV, PDF) с фильтрацией
4. **Уведомления:** Push-уведомления о новых чеках, завершении анализа
5. **Интеграция с бухгалтерией:** API для 1С, МойСклад и других систем
6. **Распознавание категорий:** Автоматическая категоризация услуг через ML
7. **Мультиязычность:** Поддержка английского и других языков
8. **Шаблоны отчетов:** Настраиваемые отчеты по чекам с агрегацией
9. **Архивация:** Автоматическое архивирование старых чеков
10. **Webhook интеграции:** Уведомления в Slack, Discord при новых чеках
11. **Права доступа:** Разграничение прав для групповых чатов (админы, участники)
12. **Backup автоматический:** Периодическое резервное копирование данных пользователей

## Тестирование

### Ручное тестирование
Отправить в бота:
1. Одиночное фото чека
2. Альбом из нескольких чеков
3. PDF файл чека
4. Ссылку на чек ФНС

### Проверка результатов
1. Корректность распознанных данных
2. Наличие файла на Drive в правильной папке
3. Наличие записи в Google Sheets
4. Корректность ссылок

## Deployment

### Требования
- Python 3.12+
- Системные библиотеки: libzbar0, tesseract-ocr, poppler-utils
- Доступ к интернету
- Google Cloud проект с включенными API

### Запуск
```bash
python3 bot.py
```

### Мониторинг
Логи выводятся в stdout с уровнем INFO. Для production рекомендуется настроить ротацию логов и мониторинг ошибок.
