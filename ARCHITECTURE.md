# Архитектура Receipt Parser Yomi Bot

## Обзор системы

Receipt Parser Yomi Bot - это Telegram-бот для автоматической обработки чеков самозанятых с последующей загрузкой на Google Drive и добавлением данных в Google Sheets.

## Компоненты системы

### 1. Telegram Bot Layer (`bot.py`)

**Назначение:** Основной интерфейс взаимодействия с пользователем через Telegram.

**Основные функции:**
- Обработка команд (`/start`)
- Прием фото чеков (одиночных и альбомов)
- Прием PDF документов
- Обработка текстовых сообщений (ссылок на чеки ФНС)
- Интерактивное подтверждение данных через inline-кнопки

**Хранилище данных:**
- `pending_receipts` - временное хранилище обрабатываемых чеков
- `media_groups` - управление альбомами фотографий

**Основные обработчики:**
- `handle_photo()` - обработка фотографий
- `handle_document()` - обработка PDF файлов
- `handle_text()` - обработка текстовых сообщений
- `button_callback()` - обработка нажатий на кнопки

### 2. Receipt Processing Layer

#### 2.1 Receipt Processor (`receipt_processor.py`)

**Назначение:** Координация процесса обработки чека.

**Основные методы:**
- `process_receipt_image(image_path)` - полная обработка изображения чека
- `upload_and_save(image_path, receipt_data)` - загрузка на Drive и сохранение в Sheets

**Рабочий процесс:**
1. Извлечение QR-кода (если есть)
2. Парсинг данных через OpenAI Vision
3. Валидация данных
4. Координация загрузки

#### 2.2 OpenAI Vision Parser (`openai_vision.py`)

**Назначение:** Извлечение данных из изображения чека с помощью GPT-4o-mini Vision API.

**Основные методы:**
- `parse_receipt(image_path)` - отправка изображения в OpenAI и получение структурированных данных
- `encode_image(image_path)` - кодирование изображения в base64

**Извлекаемые данные:**
- ФИО (Фамилия И.О.)
- Сумма (с символом ₽)
- Наименование услуг
- ИНН продавца (12 цифр)
- ИНН покупателя (10 или 12 цифр)
- Дата (dd.mm.yyyy)
- Статус (Действителен/Аннулирован)

#### 2.3 QR Parser (`qr_parser.py`)

**Назначение:** Извлечение и парсинг QR-кодов с чеков ФНС.

**Основные функции:**
- `extract_qr_from_image(image_path)` - извлечение URL из QR-кода
- `parse_fns_url(url)` - парсинг URL ФНС для получения ИНН и ID чека

**Технологии:**
- `pyzbar` - основной метод декодирования
- `opencv` - улучшение качества изображения для декодирования

#### 2.4 OCR Handler (`ocr_handler.py`)

**Назначение:** Резервный метод извлечения данных через OCR (в настоящее время не используется в основном потоке).

**Основные функции:**
- `extract_text_from_image(image_path)` - OCR через Tesseract
- `parse_receipt_data(ocr_text)` - извлечение структурированных данных из текста
- `validate_and_clean_data(data)` - валидация извлеченных данных

### 3. Google Integration Layer

#### 3.1 Google Authentication (`google_auth.py`)

**Назначение:** Управление авторизацией в Google API.

**Основные функции:**
- `get_google_credentials()` - получение и обновление credentials
- Автоматическая авторизация при первом запуске
- Сохранение токенов в `token.pickle`

**Области доступа (SCOPES):**
- `drive.file` - создание и управление файлами на Drive
- `spreadsheets` - чтение и запись в Google Sheets

#### 3.2 Drive Handler (`drive_handler.py`)

**Назначение:** Управление файлами на Google Drive.

**Структура папок:**
```
Root Folder (GOOGLE_DRIVE_FOLDER_ID)
└── ИНН покупателя (например: 9705246070)
    └── Месяц-год (например: 08-2025)
        └── Файлы чеков (Фамилия И.О. дата.jpg)
```

**Основные методы:**
- `upload_file()` - загрузка файла с автоматическим созданием структуры папок
- `get_or_create_folder()` - создание или получение папки

**Формат имени файла:** `{ФИО} {дата}.{расширение}`  
Пример: `Сабатаров А.Г. 13.08.2025.jpg`

#### 3.3 Sheets Handler (`sheets_handler.py`)

**Назначение:** Управление данными в Google Sheets.

**Структура таблицы:**
| Дата | ФИО | ИНН покупателя | Наименование услуг | Сумма | Статус | Ссылка ФНС | Ссылка Drive |
|------|-----|----------------|-------------------|-------|--------|-----------|--------------|

**Основные методы:**
- `add_receipt_data(data)` - добавление строки с данными чека
- `setup_headers()` - установка заголовков таблицы (однократно)

## Поток данных

### Обработка одиночного фото

```
1. Пользователь отправляет фото
   ↓
2. bot.py: handle_photo()
   ↓
3. Скачивание во временный файл
   ↓
4. receipt_processor.process_receipt_image()
   ├── qr_parser.extract_qr_from_image() → получение URL ФНС
   ├── openai_vision.parse_receipt() → извлечение данных
   └── ocr_handler.validate_and_clean_data() → валидация
   ↓
5. Отображение данных пользователю с кнопками
   ↓
6. Пользователь подтверждает (✅ Все верно)
   ↓
7. receipt_processor.upload_and_save()
   ├── drive_handler.upload_file() → загрузка на Drive
   └── sheets_handler.add_receipt_data() → добавление в таблицу
   ↓
8. Отправка результата пользователю
```

### Обработка альбома фотографий

```
1. Пользователь отправляет альбом (media_group)
   ↓
2. bot.py: handle_photo() для каждого фото
   ├── Группировка по media_group_id
   └── Установка задержки 2 секунды
   ↓
3. process_media_group_delayed()
   ├── Ожидание всех фото в альбоме
   └── Обработка каждого фото:
       ├── Скачивание
       ├── Парсинг через process_receipt_image()
       ├── Автоматическая загрузка upload_and_save()
       └── Сбор статистики (успешные/неуспешные)
   ↓
4. Отправка сводного отчета пользователю
```

### Обработка PDF

```
1. Пользователь отправляет PDF
   ↓
2. bot.py: handle_document()
   ↓
3. Проверка расширения .pdf
   ↓
4. Скачивание во временный файл
   ↓
5. pdf2image.convert_from_path() → конвертация в JPG
   ↓
6. receipt_processor.process_receipt_image()
   ↓
7. Отображение данных с кнопками подтверждения
   ↓
8. Загрузка оригинального PDF (не JPG) на Drive
```

## Технологический стек

### Backend
- **Python 3.12** - основной язык
- **python-telegram-bot 20.7** - Telegram Bot API
- **OpenAI Python SDK** - интеграция с GPT-4o-mini Vision

### Computer Vision & OCR
- **pyzbar** - декодирование QR-кодов
- **opencv-python** - обработка изображений
- **pytesseract** - OCR (резервный метод)
- **pdf2image** - конвертация PDF в изображения
- **Pillow** - работа с изображениями

### Google APIs
- **google-api-python-client** - клиент для Google APIs
- **google-auth-oauthlib** - OAuth 2.0 авторизация
- **google-auth-httplib2** - HTTP транспорт

### Утилиты
- **python-dotenv** - управление переменными окружения
- **requests** - HTTP запросы

## Конфигурация

### Переменные окружения (.env)

```env
TELEGRAM_BOT_TOKEN=your_telegram_bot_token
GOOGLE_DRIVE_FOLDER_ID=your_drive_folder_id
GOOGLE_SHEET_ID=your_spreadsheet_id
OPENAI_API_KEY=your_openai_api_key
```

### Файлы конфигурации

- `credentials.json` - OAuth 2.0 credentials от Google Cloud
- `token.pickle` - сохраненные Google API токены (генерируется автоматически)
- `.env` - переменные окружения (не в git)

## Безопасность

### Секретные данные
Все секретные данные хранятся в переменных окружения и не коммитятся в репозиторий:
- Telegram Bot Token
- OpenAI API Key
- Google OAuth credentials

### .gitignore
```
.env
credentials.json
token.pickle
token.json
```

### OAuth Flow
При первом запуске приложение открывает браузер для авторизации в Google. После успешной авторизации токены сохраняются локально в `token.pickle`.

## Обработка ошибок

### На уровне Bot
- Отлов всех исключений с логированием
- Информативные сообщения об ошибках пользователю
- Автоматическая очистка временных файлов

### На уровне процессинга
- Валидация обязательных полей
- Проверка форматов данных (ИНН, дата)
- Резервные методы извлечения данных

### На уровне интеграций
- Обновление Google токенов при истечении
- Обработка ошибок API (rate limits, timeouts)
- Retry механизмы для HTTP запросов

## Масштабируемость

### Текущие ограничения
- Временное хранилище в памяти (`pending_receipts`, `media_groups`)
- Синхронная обработка альбомов
- Отсутствие персистентности данных

### Рекомендации для production
1. **Хранилище:** Использовать Redis/PostgreSQL вместо in-memory словарей
2. **Очереди:** Внедрить Celery/RQ для асинхронной обработки
3. **Логирование:** Централизованное логирование (ELK, Sentry)
4. **Мониторинг:** Метрики обработки, алерты на ошибки
5. **Кэширование:** Кэширование результатов OpenAI для одинаковых изображений

## Стоимость использования

- **OpenAI GPT-4o-mini Vision:** ~$0.0003 за чек (~0.03₽)
- **Google Drive API:** Бесплатно (в пределах квот)
- **Google Sheets API:** Бесплатно (в пределах квот)
- **Telegram Bot API:** Бесплатно

**Квоты Google API:**
- Drive: 1 000 000 запросов/день
- Sheets: 500 запросов/100 секунд на пользователя

## Расширяемость

### Возможные улучшения
1. **Редактирование данных:** UI для ручной корректировки распознанных данных
2. **Статистика:** Дашборд с аналитикой по чекам
3. **Экспорт:** Выгрузка данных в различных форматах (Excel, CSV, PDF)
4. **Уведомления:** Push-уведомления о новых чеках
5. **Интеграция с бухгалтерией:** API для 1С, МойСклад и др.
6. **Распознавание категорий:** Автоматическая категоризация услуг
7. **Мультиязычность:** Поддержка английского языка

## Тестирование

### Ручное тестирование
Отправить в бота:
1. Одиночное фото чека
2. Альбом из нескольких чеков
3. PDF файл чека
4. Ссылку на чек ФНС

### Проверка результатов
1. Корректность распознанных данных
2. Наличие файла на Drive в правильной папке
3. Наличие записи в Google Sheets
4. Корректность ссылок

## Deployment

### Требования
- Python 3.12+
- Системные библиотеки: libzbar0, tesseract-ocr, poppler-utils
- Доступ к интернету
- Google Cloud проект с включенными API

### Запуск
```bash
python3 bot.py
```

### Мониторинг
Логи выводятся в stdout с уровнем INFO. Для production рекомендуется настроить ротацию логов и мониторинг ошибок.
